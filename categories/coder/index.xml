<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Coder - 分类 - zJxin</title>
        <link>https://heisenbergv.github.io/categories/coder/</link>
        <description>Coder - 分类 - zJxin</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>zuojxin@hotmail.com (zJxin)</managingEditor>
            <webMaster>zuojxin@hotmail.com (zJxin)</webMaster><lastBuildDate>Mon, 07 Apr 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://heisenbergv.github.io/categories/coder/" rel="self" type="application/rss+xml" /><item>
    <title>LLM平台</title>
    <link>https://heisenbergv.github.io/posts/2025/llm%E5%B9%B3%E5%8F%B0/</link>
    <pubDate>Mon, 07 Apr 2025 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2025/llm%E5%B9%B3%E5%8F%B0/</guid>
    <description><![CDATA[LLM应用开发平台是什么 LLM: LLM的全称是 ​​Large Language Model（大语言模型）​​，专指通过海量文本数据训练、能理解和生成自然语言的超大规]]></description>
</item>
<item>
    <title>AI生产</title>
    <link>https://heisenbergv.github.io/posts/2025/20250324/</link>
    <pubDate>Mon, 24 Mar 2025 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2025/20250324/</guid>
    <description><![CDATA[AI的冲击 最近我深刻感受到，AI对程序员的影响真是前所未有地强！为了应对这种变化，我把自己的工作模式记录下来，尽量抽象、通用一点，不盯着某个]]></description>
</item>
<item>
    <title>架构设计学习指南</title>
    <link>https://heisenbergv.github.io/posts/2023/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/</link>
    <pubDate>Sun, 02 Jul 2023 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2023/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/</guid>
    <description><![CDATA[一、架构设计基础 1. 编程范式与架构设计 结构化编程：对程序控制权的直接转移进行限制和规范 面向对象编程：强调封装、继承和多态 函数式编程：强调不可变]]></description>
</item>
<item>
    <title>crawlergo源码</title>
    <link>https://heisenbergv.github.io/posts/2023/20230104/</link>
    <pubDate>Wed, 04 Jan 2023 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2023/20230104/</guid>
    <description><![CDATA[目录 ├─cmd │ └─main.go # 程序主入口 └─pkg ├─config # 一些配置相关 ├─engine # chrome相关程序 ├─filter]]></description>
</item>
<item>
    <title>软件设计随想</title>
    <link>https://heisenbergv.github.io/posts/2021/20211107-design/</link>
    <pubDate>Sun, 07 Nov 2021 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2021/20211107-design/</guid>
    <description><![CDATA[在我看来软件设计主要做两件事一个是划分边界另一个是做权衡。 划分边界往小了说就是一个变量应该放到哪个模块（类或包），往大了说一个功能应属于哪个]]></description>
</item>
<item>
    <title>redis-单机场景</title>
    <link>https://heisenbergv.github.io/posts/2021/20210906-redis/</link>
    <pubDate>Mon, 06 Sep 2021 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2021/20210906-redis/</guid>
    <description><![CDATA[我把单机和集群分开总结，这篇主要是单机下的基础，优化方案等 概要 有些细节直接看书就行，就不再重复了，一些常用的命令也不说了。重点说使用场景，注]]></description>
</item>
<item>
    <title>vscode&#43;dlv 远程调试</title>
    <link>https://heisenbergv.github.io/posts/2021/20210813-dlv/</link>
    <pubDate>Fri, 13 Aug 2021 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2021/20210813-dlv/</guid>
    <description><![CDATA[dlv在服务器排查程序问题，没有可视化界面比较繁琐，利用vscode+dlv 远程调试，就和在本地调试一样简单 安装 在服务器和本地开发环境都要安]]></description>
</item>
<item>
    <title>gin源码</title>
    <link>https://heisenbergv.github.io/posts/2021/20210721-gin/</link>
    <pubDate>Wed, 21 Jul 2021 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2021/20210721-gin/</guid>
    <description><![CDATA[gin是go开发的一个开源高性能http框架，其主要是把go官方的net/http进行了扩展，前缀树实现了动态路由、支持了中间件、对请求信息]]></description>
</item>
<item>
    <title>grpc-go</title>
    <link>https://heisenbergv.github.io/posts/2021/20210119-grpc/</link>
    <pubDate>Tue, 19 Jan 2021 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2021/20210119-grpc/</guid>
    <description><![CDATA[grpc Server 本文简单阅读源代码，了解grpc server的执行流程，从建立连接，到处理一条请求的过程。 使用方式 使用方式很简单，生成pb，注册建立服务]]></description>
</item>
<item>
    <title>计算机网络-传输层</title>
    <link>https://heisenbergv.github.io/posts/2021/20210105-tcpudp/</link>
    <pubDate>Tue, 05 Jan 2021 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2021/20210105-tcpudp/</guid>
    <description><![CDATA[TCP/IP 模型 应用层将数据传递给传输层，传输层将数据分段，每段加入自己的首部数据，然后传递给下一层，之后的每层都会封装上自己层需要的首部，最后经过物]]></description>
</item>
<item>
    <title>源码阅读 - go Context</title>
    <link>https://heisenbergv.github.io/posts/2020/20200401-go-context/</link>
    <pubDate>Wed, 01 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2020/20200401-go-context/</guid>
    <description><![CDATA[Context有什么用 当处理一个请求A，而这个请求需要在3秒内完成相应，A请求分别创建了B和C goroutine来处理逻辑，如果B或者C处理]]></description>
</item>
<item>
    <title>读CSAPP(4) - 虚拟内存</title>
    <link>https://heisenbergv.github.io/posts/2019/20190928-csapp4/</link>
    <pubDate>Sat, 28 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2019/20190928-csapp4/</guid>
    <description><![CDATA[虚拟内存系统解决了物理寻址的缺点。利用内存管理单元（MMU）和页表（Page Table）将虚拟地址转换为物理内存地址。 进程运行过程不再加载全]]></description>
</item>
<item>
    <title>读CSAPP(3) - 存储器层次结构</title>
    <link>https://heisenbergv.github.io/posts/2019/20190923-csapp3/</link>
    <pubDate>Mon, 23 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2019/20190923-csapp3/</guid>
    <description><![CDATA[了解硬件 随机访问存储器（Random-Access Memory，RAM） RAM分两类，静态（SRAM）的和动态的（DRAM），SRAM要比D]]></description>
</item>
<item>
    <title>Go Channel</title>
    <link>https://heisenbergv.github.io/posts/2019/20190917-go-channel/</link>
    <pubDate>Tue, 17 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2019/20190917-go-channel/</guid>
    <description><![CDATA[如何使用 channel在&lt;-左边 表示向channel发送数据 channel在&lt;-右边 表示从channel接收数据 close(channelName) 关闭一个cha]]></description>
</item>
<item>
    <title>Go Groutine</title>
    <link>https://heisenbergv.github.io/posts/2019/20190917-go-groutine/</link>
    <pubDate>Tue, 17 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2019/20190917-go-groutine/</guid>
    <description><![CDATA[并发与并行 并行(parallel): 指在同一时刻,有多条指令在多个处理器上同时执行(靠机器) 并发(concurrency): 指在同一时刻只能]]></description>
</item>
<item>
    <title>读CSAPP(2) - 程序性能优化</title>
    <link>https://heisenbergv.github.io/posts/2019/20190909-csapp2/</link>
    <pubDate>Mon, 09 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2019/20190909-csapp2/</guid>
    <description><![CDATA[高效的程序需要做到 合适的数据结构与算法 编写出编译器能够有效优化以转换成高效可执行代码的源码。 将运算量特别大的计算，可以分成多部分，这些部分可]]></description>
</item>
<item>
    <title>Go 竞态问题</title>
    <link>https://heisenbergv.github.io/posts/2019/20190903-go-race-condition/</link>
    <pubDate>Tue, 03 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2019/20190903-go-race-condition/</guid>
    <description><![CDATA[定义 单处理器中低优先级的进程被高优先级的进程抢占，同时他们访问同一块共享资源 多处理器中，CPU1的进程、CPU2的进程同时访问同一块共享资源]]></description>
</item>
<item>
    <title>读CSAPP(1) - 信息的表示和处理</title>
    <link>https://heisenbergv.github.io/posts/2019/20190827-csapp1/</link>
    <pubDate>Tue, 27 Aug 2019 00:00:00 &#43;0000</pubDate>
    <author>zJxin</author>
    <guid>https://heisenbergv.github.io/posts/2019/20190827-csapp1/</guid>
    <description><![CDATA[计算机存的什么 计算机存储的是二进制，每一位存储的是0或1。大多数计算机使用1字节（也就是8位），作为最小可寻址的内存单位。 每个字节都有一个唯]]></description>
</item>
</channel>
</rss>
